[
{
	"uri": "https://gogatekeeper.github.io/configuration/",
	"title": "Configuration Options",
	"tags": [],
	"description": "",
	"content": "These configuration options can either be defined\n as a command line parameter (use --kebab-case-config-option) in a yaml/json file (use kebab-case-keys) through environment variables (only for those where environment variables are defined below)  Options issued at the command line have a higher priority and will override or merge with options referenced in a config file.\naccess-token-duration  Environment Variable: None Example: 48h, (any string that can be parsed by ParseDuration Required: No Default: 720 hours (30 days) Related: -   Defines a default access token lifetime if the expiration was not defined by the authorization server.\nThe access token expiration is normally read from the refresh token, but if that lifetime is not positive, the configured access-token-duration will be used instead.\n add-claims  Environment Variable: None Example: email, email|Foo-Bar-Email Required: No Default: No claims added as headers Related: -   Allows you to inject claims from the token as headers in the upstream request.\nFor example, to inject the user\u0026rsquo;s email, specify\nadd-claims: - email If the token contains the email claim, the value of the claim will be injected as the header X-Auth-Email in the upstream request.\nThe X-Auth- prefix is automatically added, and the header is also capitalized and joined with dashes. Any symbols in this list: _$\u0026gt;\u0026lt;[].,+-/'%^\u0026amp;*()!\\ will be replaced by dashes (-).\nadd-claims: - given_name The above will inject given_name from the token as the X-Auth-Given-Name header in the request going upstream.\nTo control the name of the header, use the pipe (|) character:\nadd-claims: - `email|Foo-Bar-Email` The above will inject email from the token as the Foo-Bar-Email header in the request going upstream.\n base-uri  Environment Variable: PROXY_BASE_URI Example: /base-uri Required: No Default: \u0026quot;\u0026quot; Related: -   base-uri is the the base URI of your app. This is where your app lives at the domain, so if your domain is https://www.example.com and your app is at the path https://www.example.com/app, then base URI should be /app.\nThis is used to\n build oauth related paths, such as the /logout endpoint set the path for cookies, which determines which parts of your site the cookie is valid on, which in turn determines if the user remains authenticated as they visit different parts of the site   client-id  Environment Variable: PROXY_CLIENT_ID Example: whoami (refer to demo) Required: Yes, unless skip-token-verification is set, and gatekeeper is in reverse proxy mode Default: None Related: client-secret   client-id is the Client ID for an OAuth2 client (your app is the OAuth2 client, in this case).\nIn reverse proxy mode As part of the OAuth2 authorization code flow, gatekeeper will use client-id and client-secret to authenticate with the server when it needs to\n exchange the authorization code for tokens refresh the access token  The client ID and secret are also used to invoke the revocation URL at the authorization server.\nIf the login handler is enabled (enable-login-handler), the credentials are also used to login at the authorization provider using the OAuth2 Resource Owner Password Credentials flow.\nclient-id is also used to check access tokens to ensure that client-id is among the audiences in the aud field of the token.\nIn forward-signing proxy mode gatekeeper will use client-id and client-secret to authenticate with the server to get tokens for outbound requests.\n client-secret  Environment Variable: PROXY_CLIENT_SECRET Example: 932475b6-9748-41b8-8fd7-c6ce2d845ece (refer to demo) Required: Yes, unless skip-token-verification is set, and gatekeeper is in reverse proxy mode Default: None Related: client-id   client-secret is the client secret for an OAuth2 client (your app is the OAuth2 client, in this case). This is used with client-id as a pair of credentials. See client-id for how this is used.\n content-security-policy  Environment Variable: None Example: default-src 'self' Required: No Default: Unspecified Related: enable-security-filter   This configuration option allows you to specify your Content Security Policy. More information on MDN\nenable-security-filter has to be true to enable this.\n cookie-access-name  Environment Variable: None Example: foobar (any cookie name) Required: No Default: kc-access Related: cookie-refresh-name   Defines the name of the cookie that gatekeeper will use to store the access token.\n cookie-domain  Environment Variable: None Example: foobar.org Required: No Default: Uses the domain from the Host header Related: -   Defines the Domain attribute for the cookies stored on the browser.\nSince the cookies contain the access and refresh token, this setting determines how much of your domain this sign-in covers.\nFor example, if Domain is set to foobar.org, when the user visits foobar.org or any of the subdomains baz.foobar.org or quux.foobar.org, the cookies will be sent to gatekeeper and the user will continue to be signed in.\nSee more information about setting the Domain attribute at MDN\n cookie-refresh-name  Environment Variable: None Example: foobar (any cookie name) Required: No Default: kc-state Related: cookie-access-name   Defines the name of the cookie that gatekeeper will use to store the refresh token.\n cors-credentials  Environment Variable: None Example: true Required: No Default: false Related: cors-origins, cors-methods, cors-headers, cors-exposed-headers, cors-max-age   If set, gatekeeper will set the Access-Control-Allow-Credentials header with the value true.\n cors-origins has to be set before this configuration option takes effect\n  cors-exposed-headers  Environment Variable: None Example: X-Foo-Bar Required: No Default: [] Related: cors-origins, cors-methods, cors-headers, cors-credentials, cors-max-age   This is a list of headers that will be added to the Access-Control-Expose-Headers header.\n cors-origins has to be set before this configuration option takes effect\n  cors-headers  Environment Variable: None Example: X-Foo-Bar Required: No Default: [\u0026quot;Origin\u0026quot;, \u0026quot;Accept\u0026quot;, \u0026quot;Content-Type\u0026quot;, \u0026quot;X-Requested-With\u0026quot;] Related: cors-origins, cors-methods, cors-exposed-headers, cors-credentials, cors-max-age   This is a list of allowed headers that will be added to the Access-Control-Allow-Headers header.\nOrigin will always be appended to the requested list.\n cors-origins has to be set before this configuration option takes effect\n  cors-max-age  Environment Variable: None Example: 600 Required: No Default: Use browser/client default Related: cors-origins, cors-methods, cors-headers, cors-exposed-headers, cors-credentials   This sets how long (in seconds) the results of a preflight request can be cached for the request coming to gatekeeper. Sets the Access-Control-Max-Age header.\n cors-origins has to be set before this configuration option takes effect\n  cors-methods  Environment Variable: None Example: GET, POST Required: No Default: [\u0026quot;GET\u0026quot;, \u0026quot;POST\u0026quot;, \u0026quot;HEAD\u0026quot;] Related: cors-origins, cors-headers, cors-exposed-headers, cors-credentials, cors-max-age   This is a list of methods that will be added to the Access-Control-Allow-Methods header.\n cors-origins has to be set before this configuration option takes effect\n  cors-origins  Environment Variable: None Example: https://example.com Required: No Default: No CORS headers will be added Related: cors-methods, cors-headers, cors-exposed-headers, cors-credentials, cors-max-age   This is a list of origins that will be added to the Access-Control-Allow-Origin header.\n disable-all-logging  Environment Variable: None Example: true or false Required: No Default: false Related: -   If true, gatekeeper will not log to stdout or stderr.\n discovery-url  Environment Variable: PROXY_DISCOVERY_URL Example: https://keycloak.localhost/auth/realms/applications (refer to demo) Required: Yes, unless skip-token-verification is set, and gatekeeper is in reverse proxy mode Default: None Related: skip-openid-provider-tls-verify, openid-provider-proxy, openid-provider-timeout   gatekeeper will get information about the authorization server through the authorization server\u0026rsquo;s openid-configuration well-known URI, according to RFC8414.\ngatekeeper will grab this metadata from discovery-url + /.well-known/openid-configuration as is registered with IANA\nSpecify discovery-url without /.well-known/openid-configuration.\nHere are links to information about discovery-urls for some other OAuth providers\n Google Identity Platform Auth0 IdentityServer4 PingFederate   enable-authorization-cookies  Environment Variable: PROXY_ENABLE_AUTHORIZATION_COOKIES Example: true or false Required: No Default: true Related: -   If this is set, gatekeeper will add the authorization cookies to the upstream proxy request (containing access and refresh tokens).\n enable-authorization-header  Environment Variable: PROXY_ENABLE_AUTHORIZATION_HEADER Example: true or false Required: No Default: true Related: -   If this is set, the access token will be added to the request going to the upstream service as the Authorization header:\nAuthorization: Bearer \u0026lt;access_token\u0026gt;  enable-compression  Environment Variable: None Example: true or false Required: No Default: false Related: -   Enables gzip compression for response from gatekeeper to browser.\n enable-default-deny  Environment Variable: None Example: true or false Required: No Default: true Related: resources   Used in conjunction with resources for authorization.\nIf set, gatekeeper will deny all requests to the upstream by default. This can then be relaxed with definition of resources.\n enable-encrypted-token  Environment Variable: None Example: true or false Required: No Default: false Related: force-encrypted-cookie, encryption-key   If set, gatekeeper will\n Encrypt the access token in the cookie that is set for the browser with encryption-key Assume that incoming access tokens in the Authorization header are also encrypted, and will decrypt the token before using it   enable-forwarding  Environment Variable: None Example: true or false Required: No Default: false Related: -   Sets gatekeeper in a forward proxy mode, for signing outbound requests. This is mutually exclusive with the default reverse proxy mode.\n enable-https-redirect  Environment Variable: None Example: true or false Required: No Default: false Related: enable-security-filter   If this is set, gatekeeper will redirect all http requests to https.\nenable-security-filter has to be true for this to work.\n enable-json-logging  Environment Variable: None Example: true or false Required: No Default: false Related: -   If set, logging is formatted in json.\nIf the regular log is like this,\n2020-12-26T06:21:38.851Z info src/middleware.go:146 client request {\u0026quot;latency\u0026quot;: 0.000209767, \u0026quot;status\u0026quot;: 303, \u0026quot;bytes\u0026quot;: 322, \u0026quot;client_ip\u0026quot;: \u0026quot;172.18.0.2:39368\u0026quot;, \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/oauth/authorize\u0026quot;} the json version is like this.\n{\u0026quot;level\u0026quot;:\u0026quot;info\u0026quot;,\u0026quot;ts\u0026quot;:\u0026quot;2020-12-26T06:21:38.851Z\u0026quot;,\u0026quot;caller\u0026quot;:\u0026quot;src/middleware.go:146\u0026quot;,\u0026quot;msg\u0026quot;:\u0026quot;client request\u0026quot;,\u0026quot;latency\u0026quot;:0.000209767,\u0026quot;status\u0026quot;:303,\u0026quot;bytes\u0026quot;:322,\u0026quot;client_ip\u0026quot;:\u0026quot;172.18.0.2:39368\u0026quot;,\u0026quot;method\u0026quot;:\u0026quot;GET\u0026quot;,\u0026quot;path\u0026quot;:\u0026quot;/oauth/authorize\u0026quot;}  enable-logging  Environment Variable: None Example: true or false Required: No Default: false Related: -   If set, requests to gatekeeper are logged. Here\u0026rsquo;s a sample of the information that is logged:\n2020-12-26T06:21:38.851Z info src/middleware.go:146 client request {\u0026quot;latency\u0026quot;: 0.000209767, \u0026quot;status\u0026quot;: 303, \u0026quot;bytes\u0026quot;: 322, \u0026quot;client_ip\u0026quot;: \u0026quot;172.18.0.2:39368\u0026quot;, \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/oauth/authorize\u0026quot;} raw path is also logged if it is different from path and is not \u0026quot;\u0026quot;. See go docs for the difference between Path and RawPath.\n enable-login-handler  Environment Variable: PROXY_ENABLE_LOGIN_HANDLER Example: true or false Required: No Default: false Related: -   If this is set, the login handler will be enabled.\nBy default, the login handler listens at /oauth/login, and looks for username and password in POST data from the browser. It will then obtain an access token and refresh token from the authorization server and then manage the tokens for the user.\n enable-logout-redirect  Environment Variable: None Example: true or false Required: No Default: false Related: -   If true, when the logout address is accessed, the user will be redirected to the identity provider on logout, with a redirect_uri pointing back to the gatekeeper service.\nThe identity provider can use redirect_uri to redirect the user back to gatekeeper again.\nIf false, when the logout address is accessed, the user will remain at gatekeeper\u0026rsquo;s logout url.\n enable-metrics  Environment Variable: None Example: true or false Required: No Default: false Related: -   Setting this enables the prometheus metrics collector at /oauth/metrics. TODO add more information about metrics.\n enable-profiling  Environment Variable: None Example: true or false Required: No Default: false Related: -   Setting this turns on profiling. TODO add more information about profiling.\n enable-refresh-tokens  Environment Variable: PROXY_ENABLE_REFRESH_TOKEN Example: true or false Required: No Default: false Related: -   Set this to get gatekeeper to handle refreshing of access tokens. Otherwise, gatekeeper will just re-authenticate with the authorization server whenever the access token expires.\n enable-security-filter  Environment Variable: PROXY_ENABLE_SECURITY_FILTER Example: true or false Required: No Default: false Related: -   Enables a bunch of security checks on the request using middleware. TODO add more detail.\n enable-session-cookies  Environment Variable: None Example: true or false Required: No Default: true Related: -   If this is set, gatekeeper will define the lifetime of the cookies (containing access and refresh tokens) to \u0026ldquo;Session\u0026rdquo;, indicting that they should be cleared when the browser closes.\nThe actual behavior, however, depends on how the browser is configured. Some browsers restore sessions when restarting, so session cookies might get restored. See MDN: Lifetime of a cookie.\nIf this is set to false, the cookies will be set to expire when the token expires.\n enable-token-header  Environment Variable: None Example: true or false Required: No Default: true Related: -   If this is set, the access token will be added to the request going to the upstream service as the X-Auth-Token header.\n enabled-proxy-protocol  Environment Variable: None Example: true or false Required: No Default: false Related: -   Enables the PROXY protocol for gatekeeper, provided by proxyproto. See more at https://www.haproxy.org/download/2.3/doc/proxy-protocol.txt\n encryption-key  Environment Variable: PROXY_ENCRYPTION_KEY Example: yb96KrChmqnEOHuIbBi650T7VDqyTwLZ Required: Yes if enable-refresh-tokens is set Default: None Related: encryption-key   encryption-key is used to encrypt the refresh token.\nThe encryption-key must be either 16 or 32 characters long. If it is 16 characters long, AES-128 will be selected. Otherwise, AES-256 will be selected.\n filter-browser-xss  Environment Variable: None Example: true or false Required: No Default: false Related: enable-security-filter   Setting this adds the X-XSS-Protection header for the browser with mode=block. More information on MDN\nenable-security-filter has to be true to enable this.\n filter-content-nosniff  Environment Variable: None Example: true or false Required: No Default: false Related: enable-security-filter   Setting this adds the X-Content-Type-Options header for the browser with the value nosniff. More information on MDN\nenable-security-filter has to be true to enable this.\n filter-frame-deny  Environment Variable: None Example: true or false Required: No Default: false Related: enable-security-filter   Setting this adds the X-Frame-Options header with the value of DENY. More information on MDN\nenable-security-filter has to be true to enable this.\n forbidden-page  Environment Variable: None Example: \u0026quot;templates/forbidden.html.tmpl\u0026quot; Required: No Default: No custom forbidden page Related: tags   If forbidden-page is specified, gatekeeper will render this page and present it to the user when the user is not authorized to view some resource.\nThe format for interpolating tags is the same as the one used in sign-in-page. tags will also be used to render the forbidden page.\n force-encrypted-cookie  Environment Variable: None Example: true or false Required: No Default: false Related: enable-encrypted-token, encryption-key   Same as enable-encrypted-token. TODO confirm this.\n forwarding-domains  Environment Variable: None Example: example.com Required: No Default: Will add access token for any domains requested through gatekeeper. Related: -   If configured, gatekeeper will only add an access token (do authorization for) to any request bound for any of the domains on this list. If not specified, gatekeeper will do authorization for all domains.\nOnly used when gatekeeper is in forward proxy mode.\n forwarding-password  Environment Variable: PROXY_FORWARDING_PASSWORD Example: password Required: When gatekeeper is in forward proxy mode Default: None Related: forwarding-username   This is the password used for logging in to the Authorization Server (OAuth2 Resource Owner Password Credentials flow) when gatekeeper is in forward proxy mode.\n forwarding-username  Environment Variable: PROXY_FORWARDING_USERNAME Example: username Required: When gatekeeper is in forward proxy mode Default: None Related: forwarding-password   This is the username used for logging in to the Authorization Server (OAuth2 Resource Owner Password Credentials flow) when gatekeeper is in forward proxy mode.\n headers  Environment Variable: None Example:  headers: x-foo-bar: baz  Required: No Default: None Related: -   Add custom headers to the request that goes upstream. The headers will be capitalized:\nx-foo-bar =\u0026gt; X-Foo-Bar X-FooBar =\u0026gt; X-Foobar X-FOO-BAR =\u0026gt; X-Foo-Bar  hostnames  Environment Variable: None Example: service.com Required: No Default: [] Related: use-letsencrypt, enable-security-filter   If hostnames is set, gatekeeper will use this list of hostnames for the security filter (if enable-security-filter is set) to only allow requests for a hostname on this list of hostnames.\nhostnames is also used with use-letsencrypt. If set, the certificate manager will only request certificates for the hostnames on the list. This can be left unspecified, but will result in a LetsEncrypt certificate being requested for any hostname for which gatekeeper is run on and may result in the gatekeeper reaching the CA\u0026rsquo;s rate limit.\n http-only-cookie  Environment Variable: None Example: true or false Required: No Default: true Related: -   If true, gatekeeper will set the HttpOnly attribute on the cookies used for access and refresh tokens.\nIf set, the cookies will only be sent to the server; they will be inaccessible to the JavaScript Document.cookie API: MDN.\n letsencrypt-cache-dir  Environment Variable: None Example: /tmp/letsencrypt Required: No Default: ./cache/ Related: use-letsencrypt   This path is used to store cached Let\u0026rsquo;s Encrypt certificates.\n listen  Environment Variable: PROXY_LISTEN Example: :80 Required: Yes Default: None Related: listen-http   listen configures the main listening interface (compare with listen-http). Examples for\n regular http(s): use :80 or :443 to listen on all interfaces 127.0.0.1:443 to only listen on a certain interface unix socket: unix:///tmp/echo.sock (add the prefix unix://)  This config is passed to golang\u0026rsquo;s net.Listen(), so use strings acceptable by address.\n  listen-http  Environment Variable: PROXY_LISTEN_HTTP Example: :80 Required: Yes Default: None Related: listen   listen-http configures the secondary listening interface. This listener has no TLS support, and uses the same configuration syntax as listen.\nUsually, we only use listen and not set listen-http.\n  localhost-metrics  Environment Variable: None Example: true or false Required: No Default: false Related: -   Enforces that the metrics page can only been requested from the loopback interface, on localhost.\n match-claims  Environment Variable: None Example: aud=myapp, iss=http://example.* Required: No Default: No required claim matching Related: -   The proxy supports adding a variable list of claim matches against the presented tokens for additional access control. You can match the iss or aud to the token or custom attributes; each of the matches are regexes.\nIf match-claims is defined, the user\u0026rsquo;s claims must match all of the requested claims. You can configure this using the configuration file, like this:\nmatch-claims: aud: openvpn iss: https://keycloak.example.com/auth/realms/commons or via the CLI, like this:\n--match-claims=aud=openvpn --match-claims=iss=https://keycloak.example.com/realms/commons The above definition means that the user\u0026rsquo;s token must\n contain both aud and iss claims AND aud must match openvpn, and iss must match https://keycloak.example.com/realms/commons so foo_openvpn_bar will match openvpn use a tighter regex ^openvpn$ to match openvpn strictly  Another example: limitting the email domain permitted: if you want to limit to only users on the example.com domain:\nmatch-claims: email: ^.*@example.com$ The adapter supports matching on multi-value strings claims. The match will succeed if ONE of the values matches, for example:\nmatch-claims: perms: perm1 will successfully match\n{ \u0026#34;iss\u0026#34;: \u0026#34;https://sso.example.com\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;perms\u0026#34;: [\u0026#34;perm1\u0026#34;, \u0026#34;perm2\u0026#34;] }  max-idle-connections  Environment Variable: None Example: 50 Required: No Default: 100 Related: -   Maximum number of idle upstream/keycloak connections that gatekeeper will keep alive.\n max-idle-connections-per-host  Environment Variable: None Example: 25 Required: No Default: 50 Related: -   Maximum number of idle upstream/keycloak connections that gatekeeper will keep alive, per host. max-idle-connections-per-host must be a number \u0026gt; 0 and \u0026lt;= max-idle-connections\n no-redirects  Environment Variable: None Example: true or false Required: No Default: false Related: -   If true, gatekeeper will just return a 401 Unauthorized instead of redirecting the user to the authorization server.\n oauth-uri  Environment Variable: PROXY_OAUTH_URI Example: /base-uri Required: No Default: \u0026quot;/oauth\u0026quot; Related: -   This is the prefix for the OAuth endpoints on gatekeeper, such as (if the default /oauth is used, and base-uri is \u0026quot;\u0026quot;)\n /oauth/authorization: Redirects to the authorization server /oauth/callback: Handles callback (response) from the authorization server /oauth/expired: Checks if the token has expired /oauth/health: The healthcheck endpoint for gatekeeper /oauth/logout?redirect=url: Direct the browser here to log out /oauth/token: Return the token in a json /oauth/login: A generic endpoint for clients to perform a user credentials login to the authorization server   oauth-uri  Environment Variable: PROXY_OAUTH_URI Example: /base-uri Required: No Default: \u0026quot;/oauth\u0026quot; Related: -   This is the prefix for the OAuth endpoints on gatekeeper, such as (if the default /oauth is used, and base-uri is \u0026quot;\u0026quot;)\n /oauth/authorization: Redirects to the authorization server /oauth/callback: Handles callback (response) from the authorization server /oauth/expired: Checks if the token has expired /oauth/health: The healthcheck endpoint for gatekeeper /oauth/logout?redirect=url: Direct the browser here to log out /oauth/token: Return the token in a json /oauth/login: A generic endpoint for clients to perform a user credentials login to the authorization server   openid-provider-proxy  Environment Variable: None Example: http://proxy.example.com:80 Required: No Default: No proxy Related: -   Gatekeeper will use this proxy for requests to the OpenID provider, for example to reach the discovery url, to get tokens, etc.\n openid-provider-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 30s Related: -   Timeout for pulling OpenID configuration from the OpenID provider. Will be parsed by ParseDuration.\n preserve-host  Environment Variable: None Example: true or false Required: No Default: false Related: -   If preserve-host is true, the Host header that gatekeeper receives will be forwarded to the upstream service. Otherwise, the Host header will be set to whatever gatekeeper uses to make the request to the upstream.\n redirection-url  Environment Variable: PROXY_REDIRECTION_URL Example: 932475b6-9748-41b8-8fd7-c6ce2d845ece (refer to demo) Required: Yes, unless skip-token-verification is set, and gatekeeper is in reverse proxy mode Default: None Related: client-id   client-secret is the client secret for an OAuth2 client (your app is the OAuth2 client, in this case). This is used with client-id as a pair of credentials. See client-id for how this is used.\n request-id-header  Environment Variable: PROXY_REQUEST_ID_HEADER Example: \u0026quot;X-Request-Id\u0026quot; Required: No Default: \u0026quot;X-Request-Id\u0026quot; Related: enable-request-id   The HTTP header name for the autogenerated request ID sent as a header to the upstream service. Will be added if enable-request-id is set to true.\n resources  Environment Variable: None Example: Refer to demo Required: Yes Default: None Related: enable-default-deny   These tell gatekeeper how to authenticate or authorize the resources at the upstream.\nHere\u0026rsquo;s an example: (yaml config)\n# Deny any access that is not allowlisted on the list of resources here enable-default-deny: true # Think of this as an allowlist resources: - uri: /admin/test # Defines HTTP methods on the above uri that are allowed. # If methods is not defined, gatekeeper allows all methods methods: - GET # Defineds a list of roles the user must have in order to access the above uri # If you only want authentication, don't define any roles # gatekeeper will then check for the access token but not roles roles: - openvpn:vpn-user - openvpn:prod-vpn - test - uri: /admin/* # Wildcards are allowed! methods: - GET roles: - openvpn:vpn-user - openvpn:commons-prod-vpn If you wish to ensure all requests are authenticated you can use this:\n--resource=uri=/*  Unless specified the method is assumed to be \u0026lsquo;any|ANY\u0026rsquo;\n The HTTP routing rules follow the guidelines from chi. The ordering of the resources does not matter, the router will handle that for you.\n revocation-url  Environment Variable: PROXY_REVOCATION_URL Example: https://keycloak.localhost/auth/realms/applications/protocol/openid-connect/logout Required: No. Will attempt to discover this url from OpenID discovery-url response Default: None Related: discovery-url   If revocation-url is not specified, the end_session_endpoint of the OpenID discovery-url response will be used as the revocation-url. If neither is available, no logout at the authorization provider will be done.\nrevocation-url is used during the logout process. When the /oauth/logout endpoint on gatekeeper is called, gatekeeper will request revocation of this session\u0026rsquo;s refresh token by doing an authenticated POST to this revocation-url with the refresh token.\n same-site-cookie  Environment Variable: None Example: Three options: Strict, Lax, None (case-sensitive) Required: No Default: Lax Related: -   Gatekeeper uses this config option to set the SameSite attribute on the cookies used for access and refresh tokens.\nSee more at MDN\n scopes  Environment Variable: None Example: (yaml/json list) [\u0026quot;offline\u0026quot;, \u0026quot;foobar\u0026quot;] Required: No Default: Always appends these: [\u0026quot;openid\u0026quot;, \u0026quot;email\u0026quot;, \u0026quot;profile\u0026quot;] Related: -   These are the scopes that are requested when the client is redirected to the authorization server.\nIn Keycloak, these are the scopes that are either created as part of the client, to client scopes in the realm. For Keycloak, scopes are strings tagged to mappers. If requested by the client, the associated mappers will be applied on the tokens.\n secure-cookie  Environment Variable: None Example: true or false Required: No Default: true Related: -   If true, gatekeeper will set the Secure attribute on the cookies used for access and refresh tokens.\nIf set, the cookies will only be sent to the server with an encrypted request over the HTTPS protocol: MDN.\n server-idle-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 120s Related: server-read-timeout   This sets the maximum time gatekeeper will wait for the next request when keep-alives are enabled. If this is 0, server-read-timeout is used. If server-read-timeout is also 0, there is no timeout.\n server-read-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: server-idle-timeout   This sets gatekeeper\u0026rsquo;s maximum duration for reading the entire request from the client, including the body.\n server-write-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: -   This sets gatekeeper\u0026rsquo;s maximum duration before timing out writes of the response.\n sign-in-page  Environment Variable: None Example: \u0026quot;templates/sign_in.html.tmpl\u0026quot; Required: No Default: No custom sign in page Related: tags   By default, gatekeeper will immediately redirect users for authentication. Specify sign-in-page, the path to a custom sign-in page template, for gatekeeper will render this page and present it to the user. This can be used as a landing page for your site, to guide users to sign in at the authorization server.\nThe sign-in page will have a redirect variable passed into the scope, which holds the OAuth redirection URL. Here\u0026rsquo;s a sample custom sign-in page that you can use.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;{{ .redirect }}\u0026#34;\u0026gt;Sign-in\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; If you wish to pass additional variables into the templates, such as title, sitename and so on, you can use the --tags key=pair option, like this: --tags title=\u0026quot;This is my site\u0026quot; and the variable would be accessible from {{ .title }}.\n skip-access-token-clientid-check  Environment Variable: None Example: true or false Required: No Default: false Related: client-id   If true, gatekeeper will not check that the configured client-id is among the aud field of the access token.\n skip-access-token-issuer-check  Environment Variable: None Example: true or false Required: No Default: false Related: -   If true, gatekeeper will not check that iss in the access token matches the issuer (Authorization server).\n skip-openid-provider-tls-verify  Environment Variable: None Example: true or false Required: No Default: false Related: -   If skip-openid-provider-tls-verify is set to true, gatekeeper will skip verification of the authorization server\u0026rsquo;s (or OpenID provider\u0026rsquo;s, in this case) certificate chain and host name.\ngatekeeper will accept any certificate presented by the server and any host name in that certificate.\nThis flag is directly used to configure InsecureSkipVerify in golang\u0026rsquo;s tls package.\n skip-token-verification  Environment Variable: None Example: true or false Required: No Default: false Related: -   If true, gatekeeper will only verify expiration and roles, but skip all other token verification steps.\n skip-upstream-tls-verify  Environment Variable: None Example: true or false Required: No Default: true Related: -   Specify this to skip TLS verification for upstream requests.\nIf true, gatekeeper will not verify the upstream\u0026rsquo;s certificate chain and host name; gatekeeper will accept any certificate presented by the server and any host name in that certificate.\n store-url  Environment Variable: None Example: redis://127.0.0.1:6379, boltdb:///tmp/tokens\u0026quot; Required: No Default: Use a cookie for the refresh token Related: encryption-key   This url must be a valid url. gatekeeper only supports redis and boltdb (bbolt) for now.\nIf boltdb is used, the boltdb data snapshot file will be created at the specified path.\nThis storage is used to store refresh tokens. If no storage is specified, gatekeeper will store the refresh token, encrypted, in a cookie that is returned to the client.\nIn all cases (redis, boltdb, or cookie), the refresh token is encrypted with encryption-key.\n tags  Environment Variable: None Example: title=foobar Required: No Default: No tags for custom page rendering. Related: sign-in-page, forbidden-page   The tags used when rendering the custom pages: sign-in-page and forbidden-page.\n tls-ca-certificate  Environment Variable: None Example: /path/to/tls/ca/certificate Required: Required if tls-ca-key is specified Default: Will handle requests using self-signed certificate from elazarl/goproxy Related: tls-ca-key   tls-ca-certificate is the path to a PEM encoded certificate file. This allows gatekeeper to sign a TLS certificate for itself, using this tls-ca-certificate and tls-ca-key.\nSpecify this to enforce mutual TLS: all clients connecting to gatekeeper must present a certificate that was signed by the CA with tls-ca-certificate.\n TODO: verify if this CA cert/key only used for CONNECT?\n This path is not watched for changes, unlike for tls-private-key and tls-cert.\n tls-ca-key  Environment Variable: None Example: /path/to/tls/ca/key Required: Required if tls-ca-certificate is specified Default: Will handle requests using self-signed certificate from elazarl/goproxy Related: tls-ca-certificate   tls-ca-key is the path to a PEM encoded private key file. This allows gatekeeper to sign a TLS certificate for itself, using this tls-ca-certificate and tls-ca-key.\nThis path is not watched for changes, unlike for tls-private-key and tls-cert.\n tls-cert  Environment Variable: None Example: /path/to/tls/certificate Required: Required if tls-private-key is specified Default: No TLS configured for gatekeeper Related: tls-private-key   tls-cert is the path to the PEM encoded certificate file. This certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain.\nThis certificate is served to clients connecting to gatekeeper, for both forward and reverse proxy mode.\nThis path is watched for changes and gatekeeper will pick up new certificate files.\nNo downtime is expected for certificate rotations. Clients who connected before the certificate rotation will be unaffected and will continue as normal with all new connections presented with the new certificate.\n tls-client-certificate  Environment Variable: None Example: /path/to/tls/client/certificate Required: No Default: No client certificates used for upstream connections Related: -   If tls-client-ceritificate is provided, this certificate will be used for upstream connections, for both forward and reverse proxy modes.\nThis path is not watched for changes, unlike for tls-private-key and tls-cert.\n tls-private-key  Environment Variable: None Example: /path/to/tls/private/key Required: Required if tls-cert is specified Default: No TLS configured for gatekeeper Related: tls-cert   tls-private-key is the path to the PEM encoded private key file.\nThis private key should be the private key for tls-cert.\nThis path is watched for changes and gatekeeper will pick up new private key files.\n upstream-ca  Environment Variable: None Example: /tmp/path-to-ca-cert (PEM encoded) Required: No Default: None (Will use system cert store) Related: upstream-url   This is the TLS CA certificate that will be used to verify TLS when communicating with the upstream.\n upstream-expect-continue-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: -   Maximum amount of time that gatekeeper will wait for the upstream\u0026rsquo;s first response headers after fully writing the request headers if the request has an \u0026ldquo;Expect: 100-continue\u0026rdquo; header.\n upstream-keepalive-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: upstream-keepalives   The interval between keep-alive probes for an active network connection.\n upstream-keepalives  Environment Variable: None Example: true or false Required: No Default: true Related: upstream-keepalive-timeout   If true (the default), gatekeeper will use HTTP keep-alives when communicating with the upstream.\n upstream-response-header-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: -   Maximum amount of time that gatekeeper will wait for the upstream\u0026rsquo;s response headers after fully writing the request.\n upstream-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: -   Maximum amount of time that gatekeeper will wait to connect to the upstream.\n upstream-tls-handshake-timeout  Environment Variable: None Example: 3s, or 314ms, (any string that can be parsed by ParseDuration Required: No Default: 10s Related: -   Maximum amount of time that gatekeeper will wait for a TLS handshake.\n upstream-url  Environment Variable: PROXY_UPSTREAM_URL Example: http://whoami:80 (refer to demo) Required: Yes Default: None Related: upstream-ca   This tells gatekeeper how to contact the upstream (your app/service that is protected by gatekeeper)\n use-letsencrypt  Environment Variable: None Example: true or false Required: No Default: false Related: letsencrypt-cache-dir   If true, gatekeeper will request a certificate from Let\u0026rsquo;s Encrypt.\n verbose  Environment Variable: None Example: true or false Required: No Default: false Related: -   Set verbose to true to turn on debug/verbose logging.\n"
},
{
	"uri": "https://gogatekeeper.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "gatekeeper gatekeeper is the simple authentication and authorization proxy that gets your app off the ground!\n gatekeeper was previously known as louketo and keycloak-gatekeeper.\n Goals  To have just enough auth features (both authentication and authorization) to get your app off the ground To be well documented and easy to get started with To remain true to the roots of this project  gatekeeper will be interoperable with keycloak out of the box, but not be limited to work only with keycloak    Announcements! gatekeeper is reborn with from the ashes of louketo under the new organization gogatekeeper.\nIn the next few months, we will be working to\n Get basic CI set up Review/update/publish docs Update Keycloak documentation with new links  Watch this space!\n"
},
{
	"uri": "https://gogatekeeper.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://gogatekeeper.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]